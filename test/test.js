const fs = require('fs');
const ipfsh = require('ipfsh');
const { expect } = require('chai')
const Merklescript = require('merklescript')
const path = require('path');
const { ethers } = require('hardhat');
class Engine {
  async init() {
    this.signers = await ethers.getSigners();
    this.addresses = this.signers.map((s) => {
      return s.address
    })
    this.Factory = await ethers.getContractFactory('Factory');
    this.deployer = this.signers[0]
  }
  async deploy() {
    let factory = await this.Factory.deploy();
    await factory.deployed();
    await fs.promises.mkdir(path.resolve(__dirname, "../deployments"), { recursive: true }).catch((e) => {})
    await fs.promises.writeFile(path.resolve(__dirname, "../deployments/test.json"), JSON.stringify({ address: factory.address }))
    this.factory = factory
  }
  async clone (title, root) {
    let cidDigest = ipfsh.ctod("bafkreihe74ocygnwsmr7oao5zqrqzagb7e4j32xcmpjordz6wx5cngmmxm")
    let tx = await this.factory.genesis(root, cidDigest, false, 0)
    let r = await tx.wait()
//    let c = ipfsh.dtoc(r.events[0].args.cid)
//    let addr = r.events[0].args.group
    let ABI = require(path.resolve(__dirname, "../abi/contracts/Buffer2.sol/Buffer2.json"))
    let addrs = await this.factory.find(this.deployer.address, 0, 1)
    let addr = addrs[0]
    console.log("addr", addr)
    this.contract = new ethers.Contract(addr, ABI, this.signers[0])
    return this.contract;
  }
}
var engine
var contract;
var addresses
var deployer
describe("splitter", () => {
  beforeEach(async () => {
    // deploy factory
    engine = new Engine()
    await engine.init()
    await engine.deploy()
    addresses = engine.addresses
    deployer = engine.deployer
  })
  it('create 3 member buffer wit 1:2:7, deposit 1ETH', async () => {
    let ratio = [1,2,7]
    let values = addresses.slice(0, 3).map((a, i) => {
      return [a, Math.pow(10, 12) * ratio[i] / 10]
    })
    const script = new Merklescript({
      types: ["address", "uint256"],
      values
    })
    const key = script.root()

    // create a buffer
    let buffer = await engine.clone("test", key)

    let bufferBalanceBefore = await ethers.provider.getBalance(buffer.address);
    expect(bufferBalanceBefore).to.equal(
      ethers.utils.parseEther("0")
    )

    // Send 1 ETH
    await deployer.sendTransaction({
      to: buffer.address,
      value: ethers.utils.parseEther("1.0")
    });

    let bufferBalanceAfter = await ethers.provider.getBalance(buffer.address);
    expect(bufferBalanceAfter).to.equal(
      ethers.utils.parseEther("1.0")
    )

    // deployer withdraw
    let deployerBalanceBefore = await ethers.provider.getBalance(deployer.address);
    let tx = await buffer.withdraw(
      deployer.address,
      values[0][1],
      script.proof([ deployer.address, values[0][1] ]),
      []
    )
    let r = await tx.wait()
    // Deployer's balance after withdraw 
    let deployerBalanceAfter = await ethers.provider.getBalance(deployer.address);
    expect(deployerBalanceAfter).to.equal(
      deployerBalanceBefore
        .add(ethers.utils.parseEther("1.0").div(10))
        .sub(r.gasUsed.mul(r.effectiveGasPrice))
    )

    // alice withdraw
    let alice = engine.signers[1]
    let aliceBuffer = buffer.connect(alice)
    let aliceBalanceBefore = await ethers.provider.getBalance(alice.address);
    tx = await aliceBuffer.withdraw(
      alice.address,
      values[1][1],
      script.proof([ alice.address, values[1][1] ])
      , []
    )
    r = await tx.wait()
    // Deployer's balance after withdraw 
    let aliceBalanceAfter = await ethers.provider.getBalance(alice.address);
    expect(aliceBalanceAfter).to.equal(
      aliceBalanceBefore
        .add(ethers.utils.parseEther("1.0").div(10).mul(2))
        .sub(r.gasUsed.mul(r.effectiveGasPrice))
    )

    // bob withdraw
    let bob = engine.signers[2]
    let bobBuffer = buffer.connect(bob)
    let bobBalanceBefore = await ethers.provider.getBalance(bob.address);
    tx = await bobBuffer.withdraw(
      bob.address,
      values[2][1],
      script.proof([ bob.address, values[2][1] ])
      , []
    )
    r = await tx.wait()
    // Deployer's balance after withdraw 
    let bobBalanceAfter = await ethers.provider.getBalance(bob.address);
    expect(bobBalanceAfter).to.equal(
      bobBalanceBefore
        .add(ethers.utils.parseEther("1.0").div(10).mul(7))
        .sub(r.gasUsed.mul(r.effectiveGasPrice))
    )


  })
  it('create a 20 member buffer, deposit 5ETH, withdraw one member (1/20)', async () => {
    // set merkle root
    let values = addresses.map((a) => {
      return [a, Math.pow(10, 12) / addresses.length]
    })

    // generate a drop for 20 addresses (generated by hardhat)
    expect(values.length).to.equal(20)
    // Each address gets 10**12 / 20 => 50000000000
    for(let value of values) {
      expect(value[1]).to.equal(50000000000)
    }

    const script = new Merklescript({ types: ["address", "uint256"], values })
    const key = script.root()

    // create a buffer
    let buffer = await engine.clone("test", key)

    // Send 5 ETH
    await deployer.sendTransaction({
      to: buffer.address,
      value: ethers.utils.parseEther("5.0")
    });

    // Deployer's balance before Withdraw
    let deployerBalanceBefore = await ethers.provider.getBalance(deployer.address);

    // Buffer's balance before Withdraw => 5ETH
    let bufferBalanceBefore = await ethers.provider.getBalance(buffer.address);
    expect(bufferBalanceBefore).to.equal(
      ethers.utils.parseEther("5.0")
    )

    // The deployer withdraws 50000000000 with the proof => should work
    let tx = await buffer.withdraw(
      deployer.address,
      50000000000,
      script.proof([ deployer.address, 50000000000 ])
      , []
    )
    let r = await tx.wait()

    // Deployer's balance after withdraw 
    let deployerBalanceAfter = await ethers.provider.getBalance(deployer.address);

    // balance after = balance before + withdraw amount (5ETH/20) - gas used for withdraw
    expect(deployerBalanceAfter).to.equal(
      deployerBalanceBefore
        .add(ethers.utils.parseEther("5.0").div(20))
        .sub(r.gasUsed.mul(r.effectiveGasPrice))
    )

    // buffer balance after withdraw
    let bufferBalanceAfter = await ethers.provider.getBalance(buffer.address);
    expect(bufferBalanceAfter).to.equal(
      ethers.utils.parseEther("5.0").sub(
        ethers.utils.parseEther("5.0").div(20)
      )
    )
  })
  it('createa 20 member buffer, deposit 1ETH, withdraw one member (1/20), deposit 1ETH, withdraw one member(1/20)', async () => {
    const script = new Merklescript({
      types: ["address", "uint256"],
      values: addresses.map((a) => {
        return [a, Math.pow(10, 12) / addresses.length]
      })
    })
    const key = script.root()

    // create a buffer
    let buffer = await engine.clone("test", key)

    // Send 1 ETH
    await deployer.sendTransaction({
      to: buffer.address,
      value: ethers.utils.parseEther("1.0")
    });

    // Deployer's balance before Withdraw
    let deployerBalance1 = await ethers.provider.getBalance(deployer.address);

    // The deployer withdraws 50000000000 with the proof => should work
    let tx = await buffer.withdraw(
      deployer.address,
      50000000000,
      script.proof([ deployer.address, 50000000000 ])
      , []
    )
    let r = await tx.wait()

    // Deployer's balance after withdraw 
    let deployerBalance2 = await ethers.provider.getBalance(deployer.address);

    // balance after = balance before + withdraw amount (1ETH/20) - gas used for withdraw
    expect(deployerBalance2).to.equal(
      deployerBalance1
        .add(ethers.utils.parseEther("1.0").div(20))
        .sub(r.gasUsed.mul(r.effectiveGasPrice))
    )

    // Send 3 ETH
    tx = await deployer.sendTransaction({
      to: buffer.address,
      value: ethers.utils.parseEther("3.0")
    });
    r = await tx.wait()

    // Deployer's balance after withdraw 
    let deployerBalance3 = await ethers.provider.getBalance(deployer.address);

    // deployer balance after transfer = deployer balance before transfer + transfer amount (3ETH) - gas used for withdraw
    expect(deployerBalance3).to.equal(
      deployerBalance2
        .sub(ethers.utils.parseEther("3.0"))
        .sub(r.gasUsed.mul(r.effectiveGasPrice))
    )

    // The deployer withdraws 50000000000 shares with the proof => should work
    tx = await buffer.withdraw(
      deployer.address,
      50000000000,
      script.proof([ deployer.address, 50000000000 ])
      , []
    )
    r = await tx.wait()

    // Deployer's balance after withdraw 
    let deployerBalance4 = await ethers.provider.getBalance(deployer.address);

    // balance after = balance before + withdraw amount (3ETH/20) - gas used for withdraw
    expect(deployerBalance4).to.equal(
      deployerBalance3
        .add(ethers.utils.parseEther("3.0").div(20))
        .sub(r.gasUsed.mul(r.effectiveGasPrice))
    )

  })
  it('createa 4 member buffer, deposit 1ETH, deployer withdraws (1/4), deposit 1ETH, alice withdraws (1/4)', async () => {
    let values = addresses.slice(0, 4).map((a) => {
      return [a, Math.pow(10, 12) / 4]
    })
    const script = new Merklescript({
      types: ["address", "uint256"],
      values
    })
    const key = script.root()

    // create a buffer
    let buffer = await engine.clone("test", key)

    // Send 1 ETH
    await deployer.sendTransaction({
      to: buffer.address,
      value: ethers.utils.parseEther("1.0")
    });

    // Deployer's balance before Withdraw
    let deployerBalance1 = await ethers.provider.getBalance(deployer.address);

    // The deployer withdraws 250000000000 shareswith the proof => should work
    let tx = await buffer.withdraw(
      deployer.address,
      250000000000,
      script.proof([ deployer.address, 250000000000 ])
      , []
    )
    let r = await tx.wait()

    // Deployer's balance after withdraw 
    let deployerBalance2 = await ethers.provider.getBalance(deployer.address);


    // balance after = balance before + withdraw amount (1ETH/4) - gas used for withdraw
    expect(deployerBalance2).to.equal(
      deployerBalance1
        .add(ethers.utils.parseEther("1.0").div(4))
        .sub(r.gasUsed.mul(r.effectiveGasPrice))
    )

    // Send 1 ETH
    tx = await deployer.sendTransaction({
      to: buffer.address,
      value: ethers.utils.parseEther("1.0")
    });
    r = await tx.wait()

    // Deployer's balance after withdraw 
    let deployerBalance3 = await ethers.provider.getBalance(deployer.address);

    // deployer balance after transfer = deployer balance before transfer + transfer amount (3ETH) - gas used for withdraw
    expect(deployerBalance3).to.equal(
      deployerBalance2
        .sub(ethers.utils.parseEther("1.0"))
        .sub(r.gasUsed.mul(r.effectiveGasPrice))
    )

    let alice = engine.signers[1]
    let aliceBuffer = buffer.connect(alice)


    // The deployer withdraws 50000000000 shares with the proof => should work
    let aliceBalance1 = await ethers.provider.getBalance(alice.address)
    tx = await aliceBuffer.withdraw(
      alice.address,
      250000000000,
      script.proof([ alice.address, 250000000000 ])
      , []
    )
    r = await tx.wait()

    // Deployer's balance after withdraw 
    let aliceBalance2 = await ethers.provider.getBalance(alice.address)

    // balance after = balance before + withdraw amount (3ETH/20) - gas used for withdraw
    expect(aliceBalance2).to.equal(
      aliceBalance1
        .add(ethers.utils.parseEther("2.0").div(4))
        .sub(r.gasUsed.mul(r.effectiveGasPrice))
    )

    // send 3 ETH
    tx = await deployer.sendTransaction({
      to: buffer.address,
      value: ethers.utils.parseEther("3.0")
    });
    r = await tx.wait()
    let deployerBalance4 = await ethers.provider.getBalance(deployer.address);

    // Bob Withdraw
    let bob = engine.signers[2]
    let bobBuffer = buffer.connect(bob)
    let bobBalance1 = await ethers.provider.getBalance(bob.address)
    tx = await bobBuffer.withdraw(
      bob.address,
      250000000000,
      script.proof([ bob.address, 250000000000 ])
      , []
    )
    r = await tx.wait()
    let bobBalance2 = await ethers.provider.getBalance(bob.address)
    expect(bobBalance2).to.equal(
      bobBalance1
        .add(ethers.utils.parseEther("5.0").div(4))
        .sub(r.gasUsed.mul(r.effectiveGasPrice))
    )


    // Alice Withdraw again
    tx = await aliceBuffer.withdraw(
      alice.address,
      250000000000,
      script.proof([ alice.address, 250000000000 ])
      , []
    )
    r = await tx.wait()
    let aliceBalance3 = await ethers.provider.getBalance(alice.address)

    // balance after = balance before + withdraw amount (3ETH/20) - gas used for withdraw
    expect(aliceBalance3).to.equal(
      aliceBalance2
        .add(ethers.utils.parseEther("3.0").div(4))
        .sub(r.gasUsed.mul(r.effectiveGasPrice))
    )

    // Deployer withdraw again
    tx = await buffer.withdraw(
      deployer.address,
      250000000000,
      script.proof([ deployer.address, 250000000000 ])
      , []
    )
    r = await tx.wait()
    let deployerBalance5 = await ethers.provider.getBalance(deployer.address)

    // balance after = balance before + withdraw amount ((1ETH + 3ETH)/4) - gas used for withdraw
    expect(deployerBalance5).to.equal(
      deployerBalance4
        .add(ethers.utils.parseEther("4.0").div(4))
        .sub(r.gasUsed.mul(r.effectiveGasPrice))
    )

  })
  it("ERC20 split", async () => {
    const Token = await ethers.getContractFactory("TestERC20")
    const token = await Token.deploy(1000);
    console.log("Token address:", token.address);
    await token.deployed();

    let ratio = [1,2,7]
    let values = addresses.slice(0, 3).map((a, i) => {
      return [a, Math.pow(10, 12) * ratio[i] / 10]
    })
    const script = new Merklescript({
      types: ["address", "uint256"],
      values
    })
    const key = script.root()

    // create a buffer
    let buffer = await engine.clone("test", key)

    // becore transfer
    let bufferTokenBalanceBefore = await token.balanceOf(buffer.address);
    console.log("buffer balance before", bufferTokenBalanceBefore)
    expect(bufferTokenBalanceBefore).to.equal("0")

    // send all ERC20 to buffer
    await token.transfer(buffer.address, 1000);

    // after transfer
    let bufferTokenBalanceAfter = await token.balanceOf(buffer.address);
    console.log("buffer balance after", bufferTokenBalanceAfter)
    expect(bufferTokenBalanceAfter).to.equal("1000")

    // deployer withdraw
    let deployerTokenBalanceBefore = await token.balanceOf(deployer.address);
    console.log("deployer balance before", deployerTokenBalanceBefore)
    expect(deployerTokenBalanceBefore).to.equal("0")
    console.log("values", values)
    let tx = await buffer.withdraw(
      deployer.address,
      values[0][1],
      script.proof([ deployer.address, values[0][1] ]),
      [ token.address ]
    )
    let r = await tx.wait()

    // deployer balance should be 100
    let deployerTokenBalanceAfter = await token.balanceOf(deployer.address);
    console.log("deployer balance after", deployerTokenBalanceAfter)
    expect(deployerTokenBalanceAfter).to.equal("100")


    // buffer balance should be 900
    let bufferTokenBalanceAfter2 = await token.balanceOf(buffer.address);
    expect(bufferTokenBalanceAfter2).to.equal("900")
    console.log("buffer balance after 2", bufferTokenBalanceAfter2)


    // deployer try to withdraw again => balance should be the same because there's no additional tokens to withdraw
    let tx2 = await buffer.withdraw(
      deployer.address,
      values[0][1],
      script.proof([ deployer.address, values[0][1] ]),
      [ token.address ]
    )
    let r2 = await tx2.wait()
    console.log("X")

    // deployer balance should be 100
    deployerTokenBalanceAfter = await token.balanceOf(deployer.address);
    console.log("deployer balance after 2", deployerTokenBalanceAfter)
    expect(deployerTokenBalanceAfter).to.equal("100")
    // buffer balance should be 900
    let bufferTokenBalanceAfter3 = await token.balanceOf(buffer.address);
    console.log("buffer balance after 3", bufferTokenBalanceAfter3)
    expect(bufferTokenBalanceAfter3).to.equal("900")

  })

  it("continuous token injection", async () => {
    const Token = await ethers.getContractFactory("TestERC20")
    const token = await Token.deploy(1000);
    console.log("Token address:", token.address);
    await token.deployed();

    let ratio = [1,2,7]
    let values = addresses.slice(0, 3).map((a, i) => {
      return [a, Math.pow(10, 12) * ratio[i] / 10]
    })
    const script = new Merklescript({
      types: ["address", "uint256"],
      values
    })
    const key = script.root()

    // create a buffer
    let buffer = await engine.clone("test", key)

    // becore transfer
    let bufferTokenBalanceBefore = await token.balanceOf(buffer.address);
    console.log("buffer balance before", bufferTokenBalanceBefore)
    expect(bufferTokenBalanceBefore).to.equal("0")

    // send 100 ERC20 to buffer => deployer should now own 900 tokens, contract owns 100
    await token.transfer(buffer.address, 100);

    // buffer after transfer: 100
    let bufferTokenBalanceAfter = await token.balanceOf(buffer.address);
    expect(bufferTokenBalanceAfter).to.equal("100")

    // deployer after transfer: 900
    let deployerTokenBalanceAfter = await token.balanceOf(deployer.address);
    expect(deployerTokenBalanceAfter).to.equal("900")

    // deployer withdraw from buffer => deployer gets 10% of 100 -> now owns 900 + 10 = 910
    let tx = await buffer.withdraw(
      deployer.address,
      values[0][1],
      script.proof([ deployer.address, values[0][1] ]),
      [ token.address ]
    )
    let r = await tx.wait()

    // deployer balance should be 900 + 10 = 910
    let balance2 = await token.balanceOf(deployer.address);
    expect(balance2).to.equal("910")

    // buffer balance should be 90
    let balance3 = await token.balanceOf(buffer.address);
    expect(balance3).to.equal("90")


    // deployer try to withdraw again => balance should be the same because there's no additional tokens to withdraw
    let tx2 = await buffer.withdraw(
      deployer.address,
      values[0][1],
      script.proof([ deployer.address, values[0][1] ]),
      [ token.address ]
    )
    let r2 = await tx2.wait()
    console.log("X")

    // nothing changed
    // deployer balance should be 900 + 10 = 910
    let balance4 = await token.balanceOf(deployer.address);
    expect(balance4).to.equal("910")

    // buffer balance should be 90
    let balance5 = await token.balanceOf(buffer.address);
    expect(balance5).to.equal("90")


    // Now send some more tokens to contract
    // send 610 ERC20 to buffer => deployer should now own 910 - 610 = 300 tokens, contract owns 90 + 610 = 700
    await token.transfer(buffer.address, 610);

    let balance6 = await token.balanceOf(deployer.address);
    expect(balance6).to.equal("300")

    // buffer balance should be 90
    let balance7 = await token.balanceOf(buffer.address);
    expect(balance7).to.equal("700")


    // current balance of the buffer: 700
    // but the total injection so far: 100 + 610 => 710
    // Now withdraw again as deployer
    // => Deployer should NOT get 700 * 10% (70)
    // => instead Should get 710 * 10% - 10 = 71 - 10 = 61

    let tx3 = await buffer.withdraw(
      deployer.address,
      values[0][1],
      script.proof([ deployer.address, values[0][1] ]),
      [ token.address ]
    )
    let r3 = await tx3.wait()

    // the balance should be 300 + 61 = 361
    let balance8 = await token.balanceOf(deployer.address);
    console.log(balance8.toString())
    expect(balance8).to.equal("361")

    // buffer balance should be 700 - 61 = 639
    let balance9 = await token.balanceOf(buffer.address);
    console.log(balance9.toString())
    expect(balance9).to.equal("639")


    // Now try withdrawing as alice
    // Alice should get (total injection * 20% = 710 * 20% = 142)
    let alice = engine.signers[1]
    let aliceBuffer = buffer.connect(alice)
    let aliceBalanceBefore = await ethers.provider.getBalance(alice.address);
    tx = await aliceBuffer.withdraw(
      alice.address,
      values[1][1],
      script.proof([ alice.address, values[1][1] ]),
      [ token.address ]
    )
    r = await tx.wait()

    // the balance should be 300 + 61 = 361
    let balance10 = await token.balanceOf(deployer.address);
    console.log(balance10.toString())
    expect(balance10).to.equal("361")

    // alice balance should be 142
    let balance12 = await token.balanceOf(alice.address);
    console.log(balance12.toString())
    expect(balance12).to.equal("142")

    // buffer balance should be 639 - 142 = 497
    let balance11 = await token.balanceOf(buffer.address);
    console.log(balance11.toString())
    expect(balance11).to.equal("497")


  })
})
